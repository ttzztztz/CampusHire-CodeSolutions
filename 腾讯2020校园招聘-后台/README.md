# 腾讯 2020 校园招聘 笔试
这是在家闲着没事在牛客网上做的题，看起来是去年的？思路如下

## T1 Easy
直接暴力模拟就可以

## T2 Medium
单调栈，先从左向右遍历，维护 `[0, i)` 区间内的单调严格递减元素的个数，统计一下答案

## T3 Hard
第一眼看上去觉得线段树可做，但是代码量太大了，后来偷偷看了一眼题解，发现有更巧妙的方法

首先，长度为( `1 << k` )的某个区间`[i, j]`区间假设从中间划分成`[i, mid]`, `[mid + 1, j]`两段，那么我们执行操作 `reverse(i, mid), reverse(mid + 1, j)`之后，逆序点对的改变数量仅仅是`deltaCount(i, j) = deltaCount(i, mid) + deltaCount(mid + 1, j)`，两个区间内部的改变量，而两个区间合并产生的代价`mergeDelta(i, j)`不会改变

我们定义`layer[i]`表示第i层的所有子区间，转移到第i + 1层，增加的逆序点对数量，那么我们可以发现`count = Σlayer[i], 0 <= i <= n`

其次，每次改变都是 `1 << m`，会被 `1 << n` 整除

我们基于上述性质发现，假设我们以`1 << m`为一组进行翻转，那么每一组内部的所有元素会被反转，并且只会影响`所有k层, k <= m`层中的合并代价，并且对于每一层来说，执行反转操作等价于`swap(layer[k], reversedLayer[k])`

## T4 Medium
直接记忆化搜索即可，`f[i][j]`表示前i天，最后一天选择第j个事情的所有方案中，休息天数最少的方案

## T5 Medium
直接贪心即可，类似的题目[1024. Video Stitching](https://leetcode.com/problems/video-stitching/)